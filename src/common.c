/**
* @file common.c
 * @brief Общие утилиты и функции ядра
 * @author getname
 * @date 29.03.2025
 * @defgroup common Общие утилиты
 * @{
 */

#include "common.h"
#include "drivers/screen.h"
#include "drivers/print.h"

/**
 * @brief Копирует данные между буферами памяти
 * @param[in] src Указатель на источник данных (read-only)
 * @param[out] dst Указатель на приемник данных
 * @param[in] len Количество байт для копирования
 *
 * @note Особенности:
 * - Побайтовое копирование без оптимизаций
 * - Поддерживает длину до 4GB (U32_MAX)
 *
 * @warning:
 * - Не проверяет валидность указателей
 * - Не обрабатывает перекрывающиеся области памяти
 * - Для больших блоков используйте оптимизированную версию
 */
void memcpy(const u8 *src, u8 *dst, const u32 len) {
    u32 i = 0;
    while (i < len) {
	    dst[i] = src[i];
        i++;
    }
}

/**
 * @brief Сравнивает две строки
 * @param[in] s1 Первая строка для сравнения
 * @param[in] s2 Вторая строка для сравнения
 * @return Разницу ASCII-кодов первых различных символов:
 *         - 0: строки идентичны
 *         - >0: s1 > s2
 *         - <0: s1 < s2
 *
 * @note Сравнение прекращается при:
 * - Обнаружении первого несовпадения
 * - Достижении конца любой из строк
 *
 */
int strcmp(const char *s1, const char *s2) {
    // Пока символы совпадают и не достигнут конец строки
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }

    // Возвращаем разницу между ASCII-кодами символов
    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

/**
 * @brief Выводит строку с цветовыми атрибутами
 * @param[in] str Строка для вывода
 * @param[in] attr Атрибут цвета (формат 0xKF)
 *
 * @note Особенности:
 * - Символ '_' выводится с черным фоном (0x00)
 * - Остальные символы - с указанным атрибутом
 * - Поддерживает стандартные управляющие символы
 *
 * @see colored_print() Для расширенного форматирования
 */
void kprint_colored(u8 *str, u8 attr) {
    while (*str) {
        if (*str == '_')
            putchar(*str, 0x00);
        else
            putchar(*str, attr);
        str++;
    }
}

/**
 * @brief Выводит ASCII-арт коровы
 *
 * @note Использует многострочный массив:
 * - 5 строк ASCII-арта
 * - Цветовая схема: синий текст на белом фоне (0x01)
 *
 */
void print_cow() {
    const char *cow_art[] = {
        "  ^__^                             \n",
        "  (oo)\\_______                     \n",
        "  (__)\\       )\\/\\                \n",
        "      ||----w |                    \n",
        "      ||     ||                    \n"
    };

    // Печатаем каждую строку ASCII-арта
    for (int i = 0; i < sizeof(cow_art) / sizeof(cow_art[0]); i++) {
        colored_print(0x01, "%s", cow_art[i]);
    }
}

/**
 * @brief Выводит ASCII-арт Рика и Морти
 *
 * @note Особенности реализации:
 * - Использует комбинированный массив строк char_map
 * - Цветовая схема задается массивом color_map
 * - Поддерживает 61 элемент отображения
 * - Цвета:
 *   - 0x77: Серый на черном
 *   - 0xbb: Голубой на черном
 *   - 0xff: Белый на черном
 *   - 0xee: Желтый на черном
 *
 */
void print_rick_and_morty() {
    u8 *char_map[] = {
        "__#_#_#\n",
        "__#####____", "#####\n",
        "__#", "###", "#____", "#", "###", "#\n",
        "__#", "#", "#", "#", "#____", "#", "#", "#", "#", "#\n",
        "__#", "#", "#", "#", "#____", "#", "#", "#", "#", "#\n",
        "__#####____", "#####\n",
        "___###_____", "_###_\n",
        "__##", "#", "##____", "#####\n",
        "__##", "#", "##____", "#", "###", "#\n",
        "__##", "#", "##____", "#", "###", "#\n",
        "__#", "#", "#", "#", "#____", "#", "###", "#\n",
        "___##", "#______", "###\n",
        "___#_#______#_#\n"
    };
    u8 color_map[] = {
        0xbb,
        0xbb, 0x66,
        0xbb, 0xff, 0xbb, 0x66, 0xff, 0x66,
        0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff,
        0xff, 0xff,
        0x77, 0xbb, 0x77, 0xee,
        0x77, 0xbb, 0x77, 0xff, 0xee, 0xff,
        0x77, 0xbb, 0x77, 0xff, 0xee, 0xff,
        0xff, 0x77, 0xbb, 0x77, 0xff, 0xff, 0xee, 0xff,
        0x99, 0x77, 0x99,
        0x99
    };
    u8 i = 0;
    while (i < 61) {
        kprint_colored(char_map[i], color_map[i]);
        i++;
    }
}

/** @} */ // Конец группы common