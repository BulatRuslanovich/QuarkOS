;Функция вывода шестнадцатеричного числа на экран
; ------------------------------------------------------------------------------
;	Как выглядит регистр EAX (32 b = 32 бита):
;
;						EAX (32 b)
;		---------------------------------------------
;		|					|			|			|
;		|					|  AH (8 b)	|  AL (8 b) |
;		|					|			|			|
;		---------------------------------------------
;									AX (16 b)
;
;	Как видим, EAX содержит в себе регистр AX, который в свою очередь разделен
;	на AH (a high, верхний) и AL (a low, нижний).
; ------------------------------------------------------------------------------


; Помним, что в main.asm:
; DX  =  0x1fb6
; BX  =  "0x0000" (а точнее, BX="0", т.к. указывает на первый элемент)

print_hex:
	pusha                   ; Сохраняем все регистры общего назначения на стек
	mov cx, 0               ; CX будет использоваться как счётчик (обрабатываем 4 полубайта = 16 бит)

loop1:
	cmp cx, 4               ; Проверяем, обработали ли уже 4 цифры (4 * 4 бита = 16 бит)
	jl print                ; Если меньше 4 — продолжаем печать следующего символа
	jmp end                 ; Если 4 или больше — выходим из цикла

print:
	mov ax, dx             ; Копируем значение, которое нужно вывести (находится в DX), во временный регистр AX
	and ax, 0x000f         ; Оставляем только младшие 4 бита (один шестнадцатеричный символ)
	cmp ax, 9              ; Проверяем: число больше 9?

	jg num_to_symbol       ; Если да, то это буква (A-F), нужно прибавить другое смещение
	jmp next               ; Если нет, то это цифра (0–9), переходим к добавлению '0'

num_to_symbol:
	add ax, 39             ; Преобразуем число >9 в ASCII-код символа A-F
	                      ; Например, 10 + 39 = 49 + '0' = 65 (ASCII 'A')

next:
	add ax, '0'            ; Преобразуем оставшееся значение в ASCII символ (0–9 или A–F)
	mov bx, HEX_OUT + 5    ; Адрес последнего символа в строке "0x0000"
	sub bx, cx             ; Смещаемся влево по строке, чтобы записать следующий символ
	mov [bx], al           ; Сохраняем символ в строку
	ror dx, 4              ; Сдвигаем DX вправо на 4 бита, чтобы обработать следующий полубайт
	inc cx                 ; Увеличиваем счётчик
	jmp loop1              ; Повторяем цикл

end:
	mov bx, HEX_OUT        ; Загружаем адрес строки в BX
	call print_string      ; Вызываем функцию печати строки (предполагается, что она реализована где-то ещё)
	popa                   ; Восстанавливаем регистры
	ret                    ; Возврат из функции

; ------------------------------------------------------------------------------
; Статическая строка, в которую будет записано шестнадцатеричное представление
; числа из регистра DX. Изначально содержит "0x0000", которая потом модифицируется.

HEX_OUT:	db "0x0000", 0  ; Строка с шестнадцатеричным числом и завершающим нулём
